ban-ts-comment	3	Best Practices	Bans '// @ts-<directive>' comments from being used
no-debugger	3	Best Practices	Avoid the use of `debugger`
no-implied-eval	3	Best Practices	Avoid using 'eval()'. There are security and performance implications involved with doing so.
no-switch-case-fall-through	2	Best Practices	Avoid fallthrough of `case` statements
no-unsafe-call	3	Best Practices	Avoid calling an any type value. The any type can sometimes leak into your codebase. The arguments to, and return value of calling an any typed variable are not checked at all by TypeScript, so it creates a potential safety hole
no-unsafe-member-access	3	Best Practices	Avoid member access on any typed variables. The any type can sometimes leak into your codebase. Member access on any typed variables is not checked at all by TypeScript, so it creates a potential safety hole
no-unsafe-return	3	Best Practices	Avoid returning any from a function. The any type can sometimes leak into your codebase. Returned any typed values not checked at all by TypeScript, so it creates a potential safety hole
no-with-statement	5	Best Practices	Avoid `with` statements

no-duplicate-super	5	ECMAScript 6	require `super()` calls in constructors

await-promise	3	Functionality	Avoid awaiting a value that is not a Thenable
explicit-module-boundary-types	2	Functionality	Require explicit return and argument types on exported functions' and classes' public class methods
no-async-without-await	3	Functionality	Avoid async functions which have no await expression
no-empty-interface	3	Functionality	Avoid the declaration of empty interfaces
no-for-in-array	3	Functionality	Avoid iterating over an array with a for-in loop
no-floating-promises	2	Functionality	Handle Promise-like values properly. Unhandled promises can cause several issues, such as improperly sequenced operations, ignored Promise rejections and more
no-loss-of-precision	3	Functionality	Avoid literal numbers that lose precision
no-internal-module	3	Functionality	Require the use of the namespace keyword instead of the module keyword to declare custom TypeScript modules
no-misused-new	3	Functionality	Enforce valid definition of new and constructor
no-extra-non-null-assertion	3	Functionality	Using non-null assertion cancels the benefits of the strict null checking mode.
no-non-null-assertion	3	Functionality	Avoid non-null assertions using the ! postfix operator
no-non-null-asserted-optional-chain	3	Functionality	Avoid using a non-null assertion after an optional chain expression. Optional chain expressions are designed to return undefined if the optional property is nullish
no-promise-as-boolean	3	Functionality	Avoid using promises in places not designed to handle them
no-this-assignment	3	Functionality	Avoid aliasing this
no-unbound-method	3	Functionality	Enforces unbound methods are called with their expected scope
no-unnecessary-type-assertion	2	Functionality	Warns if a type assertion does not change the type of an expression
no-unnecessary-type-constraint	2	Functionality	Unnecessary constraints on generic types. Type parameters (<T>) may be "constrained" with an extends keyword
no-unused-variable	3	Functionality	Avoid unused variables
prefer-array-literal	3	Functionality	Avoid generic Array constructors
prefer-as-const	4	Functionality	Recomended to use usage of as const over literal type
prefer-regexp-exec	4	Functionality	Enforce that RegExp#exec is used instead of String#match if no global flag is provided. RegExp#exec is faster than String#match
restrict-plus-operands	2	Functionality	When adding two variables, operands must both be of type number or of type string
restrict-template-expressions	3	Functionality	Enforce template literal expressions to be of string type

no-reference	4	Imports	Set preference level for triple slash directives versus ES6-style import declarations
no-var-requires	4	Imports	Avoid the use of require statements except in import statements

label-position	2	Possible Error	Avoid unused labels
no-conditional-assignment	2	Possible Error	Avoid assignment operators in conditional expressions
no-constant-condition	2	Possible Error	Avoid constant expressions in conditions
no-control-regex	4	Possible Error	Avoid control characters in regular expressions
no-duplicate-switch-case	1	Possible Error	Avoid duplicate case labels
no-empty	2	Possible Error	Avoid empty block statements
no-invalid-regexp	1	Possible Error	Avoid invalid regular expression strings in `RegExp` constructors
no-regex-spaces	4	Possible Error	Avoid multiple spaces in regular expressions
no-sparse-arrays	3	Possible Error	Avoid sparse arrays
no-unsafe-finally	2	Possible Error	Avoid control flow statements in `finally` blocks
typeof-compare	2	Possible Error	Enforce comparing `typeof` expressions against valid strings
use-isnan	4	Possible Error	Require calls to `isNaN()` when checking for `NaN`

adjacent-overload-signatures	4	Style	Require that member overloads be consecutive
ban-types	4	Style	Some builtin types have aliases, some types are considered dangerous or harmful. It's often a good idea to ban certain types to help with consistency and safety.
no-any	3	Style	Avoid usage of the any type
no-inferrable-types	4	Style	Avoid explicit type declarations for variables or parameters initialized to a number, string, or boolean
no-empty-function	5	Style	Avoid empty functions. Empty functions can reduce readability
no-extra-semi	5	Style	Avoid unnecessary semicolons. While not technically an error, extra semicolons can cause confusion when reading code.
no-namespace	4	Style	Avoid the use of custom TypeScript modules and namespaces
no-unsafe-argument	3	Style	Avoid calling a function with any in its arguments, and it will disallow spreading any[]. the any type can sometimes leak into your codebase
no-unsafe-assignment	3	Style	Avoid assigning any to variables and properties
no-delete-expression	3	Variables	Avoid deleting variables