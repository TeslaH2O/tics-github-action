Dir4.3	4	Code Design	__string__ '__name__' is deprecated. __string__
Dir4.4	7	Code Design	/*' within block comment
Dir4.5	4	Code Design	__symbol__ is typographically ambiguous with respect to '__string__' when __detail__
Dir4.6	5	Code Design	Typedefs that indicate size and signedness should be used in place of the basic numerical types
Dir4.7	3	Code Design	Ignoring return value of function __symbol__
Dir4.8	3	Code Design	Complete definition of __symbol__ is unnecessary in this translation unit
Dir4.9	5	Code Design	A function should be used in preference to a function-like macro where they are interchangeable
Dir4.10	2	Code Design	Precautions shall be taken in order to prevent the contents of a header file being included more than once
Rule1.3	1	Standard C Environment	Some undefined and unspecified behaviors are dealt with by specific rules.
Rule2.1	2	Unused Code	Statement is unreachable due to unconditional transfer of control by '__string__' statement
Rule2.2	4	Unused Code	Redundant left argument to comma
Rule2.3	5	Unused Code	A project should not contain unused type declarations
Rule2.4	5	Unused Code	Tag __symbol__ unused outside of typedefs
Rule2.5	5	Unused Code	Macro '__string__' not referenced
Rule2.6	2	Unused Code	Label __name__ not referenced
Rule2.7	2	Unused Code	Named parameter __symbol__ of '__virtual/non-virtual__' function __symbol__ not subsequently referenced
Rule3.1	2	Comments	The required character sequences // and /* shall not be used within a comment
Rule3.2	2	Comments	Line-splicing shall not be used in // comments
Rule4.1	3	Character Sets and Lexical Conventions	Potentially confusing __hexadecimal/octal__ escape sequence usage
Rule4.2	5	Character Sets and Lexical Conventions	Trigraphs should not be used
Rule5.1	2	Identifiers	External identifiers shall be distinct
Rule5.3	2	Identifiers	An identifier declared in an inner scope shall not hide an identifier declared in an outer scope
Rule5.4	2	Identifiers	Macro identifiers shall be distinct
Rule5.5	3	Identifiers	Symbol __symbol__ has same name as previously defined macro
Rule5.7	2	Identifiers	A tag name shall be a unique identifier
Rule6.1	2	Types	Bit-fields shall only be declared with an appropriate type
Rule6.2	2	Types	Single-bit named bit fields shall not be of a signed type
Rule7.1	2	Literals and Constants	Octal constants shall not be used
Rule7.2	2	Literals and Constants	A "u" or "U" suffix shall be applied to all integer constants that are represented in an unsigned type
Rule7.3	2	Literals and Constants	The lowercase character "l" shall not be used in a literal suffix
Rule7.4	2	Literals and Constants	Assignment of string literal to variable __symbol__ is not const safe
Rule8.1	2	Declarations and Definitions	Types shall be explicitly specified
Rule8.2	2	Declarations and Definitions	Function types shall be in prototype form with named parameters
Rule8.3	2	Declarations and Definitions	All declarations of an object or function shall use the same names and type qualifiers
Rule8.4	2	Declarations and Definitions	A compatible declaration shall be visible when an object or function with external linkage is defined
Rule8.5	2	Declarations and Definitions	An external object or function shall be declared once in one and only one file
Rule8.7	2	Declarations and Definitions	External symbol __symbol__ could be made static
Rule8.8	2	Declarations and Definitions	The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage
Rule8.9	4	Declarations and Definitions	Could define global variable __symbol__ within function __string__
Rule8.10	2	Declarations and Definitions	Inline function __symbol__ declared without storage-class specifier
Rule8.11	5	Declarations and Definitions	When an array with external linkage is declared, its size should be explicitly specified
Rule8.12	1	Declarations and Definitions	Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique
Rule8.13	2	Declarations and Definitions	Static storage duration variable __symbol__ could be made pointer to const
Rule9.1	1	Initialization	The value of an object with automatic storage duration shall not be read before it has been set
Rule9.2	2	Initialization	The initializer for an aggregate or union shall be enclosed in braces
Rule9.3	2	Initialization	Arrays shall not be partially initialized
Rule9.4	2	Initialization	Duplicate initialization of object element
Rule9.5	3	Initialization	Designated initializer used with array of unspecified dimension
Rule10.1	2	The Essential Type Model	Operands shall not be of an inappropriate essential type
Rule10.2	2	The Essential Type Model	Expressions of essentially character type shall not be used inappropriately in addition and abstraction operations
Rule10.3	2	The Essential Type Model	The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category
Rule10.4	2	The Essential Type Model	Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category
Rule10.5	2	The Essential Type Model	Cannot cast __essential-type__ value to __essential-type__ type
Rule10.6	2	The Essential Type Model	Cannot assign a composite expression of type '__essential-type__' to an object of wider type '__essential-type__'
Rule10.7	2	The Essential Type Model	__left/right__ operand to __operator__ is a composite expression of type '__essential-type__' which is smaller than the __left/right__ operand of type '__essential-type__'
Rule10.8	2	The Essential Type Model	Cannot cast '__essential-type__' to __wider/different__ essential type '__essential-type__'
Rule11.1	2	Pointer Type Conversions	Conversions shall not be performed between a pointer to a function and any other type
Rule11.3	2	Pointer Type Conversions	A cast shall not be performed between a pointer to object type and a pointer to a different object type
Rule11.4	5	Pointer Type Conversions	A conversion should not be performed between a pointer to object and an integer type
Rule11.5	3	Pointer Type Conversion	Conversion from pointer to void to other pointer type (__type__)
Rule11.7	3	Pointer Type Conversion	Conversion between object pointer type __type__ and non-integer arithmetic essential type '__essential-type__'
Rule11.8	2	Pointer Type Conversions	A cast shall not remove any const or volatile qualification from the type pointed to by a pointer
Rule11.9	3	Pointer Type Conversion	Integer null pointer constant is not the null macro
Rule12.1	5	Expressions	The precedence of operators within expressions should be made explicit
Rule12.2	2	Expressions	The right operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand
Rule12.3	5	Expressions	The comma operator should not be used
Rule13.1	3	Side Effects	Side-effect in initializer list
Rule13.3	3	Side Effects	Increment/decrement operation combined with other operation with side-effects
Rule13.4	5	Side Effects	The result of an assignment operator should not be used
Rule13.5	2	Side Effects	The right hand operand of a logical && or || operator shall not contain persistent side effects
Rule13.6	1	Side Effects	The operand of the sizeof operator shall not contain any expression which has potential side effects
Rule14.1	2	Control Statement Expressions	A loop counter shall not have essential floating type
Rule14.3	2	Control Statement Expressions	Controlling expressions shall not be invariant
Rule14.4	2	Control Statement Expressions	The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type
Rule15.1	5	Control Flow	The goto statement should not be used
Rule15.2	5	Control Flow	Goto references earlier label __symbol__
Rule15.3	5	Control Flow	Goto appears in block __string__  which is not nested in block __string__ which contains label __symbol__
Rule15.4	5	Control Flow	Multiple loop exits
Rule15.5	5	Control Flow	A function should have a single point of exit at the end
Rule15.6	2	Control Flow	The body of an iteration-statement or a selection-statement shall be a compound-statement
Rule15.7	2	Control Flow	All if...else if constructs shall be terminated with an else statement
Rule16.1	2	Switch Statements	All switch statements shall be well-formed
Rule16.2	3	Switch statements	Most closely enclosing compound statement of this '__string__' label is not a switch statement
Rule16.3	2	Switch Statements	An unconditional break statement shall terminate every switch-clause
Rule16.7	2	Switch Statements	A switch-expression shall not have essentially Boolean type
Rule17.1	2	Functions	A +headerwarn option was previously issued for header '__file__'
Rule17.2	3	Functions	Function '__name__' is recursive
Rule17.3	2	Functions	A function shall not be declared implicitly
Rule17.4	2	Functions	All exit paths from a function with non-void return type shall have an explicit return statement with an expression
Rule17.5	2	Functions	Argument '__string__' is of insufficient length for array parameter __symbol__ declared as __type__
Rule17.6	3	Functions	Static keyword between brackets of array declaration
Rule17.8	3	Functions	Function parameter __symbol__ modified
Rule18.1	2	Pointers and Arrays	Possibly indexing before the beginning of an allocation
Rule18.2	2	Pointers and Arrays	Subtraction between pointers shall only be applied to pointers that address elements of the same array
Rule18.3	2	Pointers and Arrays	The relational operators >, >=, < and <= shall not be applied to objects of pointer type except where they point into the same object
Rule18.4	5	Pointers and Arrays	The +, -, += and -= operators should not be applied to an expression of pointer type
Rule18.5	5	Pointers and Arrays	Declarations should contain no more than two levels of pointer nesting
Rule18.6	2	Pointers and Arrays	The address of an object with automatic storage shall not be copied to another object that persists after the first object has ceased to exist
Rule18.7	3	Pointers and Arrays	Flexible array member declared
Rule18.8	3	Pointers and Arrays	Variable length array of type __type__ declared
Rule19.2	3	Overlapping Storage	Union __symbol__ declared
Rule20.1	3	Preprocessing Directives	Declaration of __symbol__ before #include
Rule20.4	2	Preprocessing Directives	A macro shall not be defined with the same name as a keyword
Rule20.5	3	Preprocessing Directives	Use of '#undef' is discouraged: '__detail__'
Rule20.6	2	Preprocessing Directives	Tokens that look like a preprocessing directive shall not occur within a macro argument
Rule20.7	2	Preprocessing Directives	Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses
Rule20.8	3	Preprocessing Directives	Conditional of __#if/#elif__ does not evaluate to 0 or 1
Rule20.9	2	Preprocessing Directives	Undefined preprocessor variable __name__, assumed 0
Rule20.10	5	Preprocessing Directives	The # and ## preprocessor operators should not be used
Rule20.11	2	Preprocessing Directives	A macro parameter immediately following a # operator shall not immediately be followed by a ## operator
Rule20.12	3	Preprocessing Directives	Macro '__name__' appearing in argument __integer__ of macro '__name__' is used both with and without '#/##' and is subject to further replacement
Rule20.13	1	Preprocessing Directives	__string__ directive not followed by eol
Rule21.1	3	Standard Libraries	Macro '__name__' is reserved to the compiler
Rule21.2	3	Resources	The name '__name__' is reserved to the compiler
Rule22.2	1	Resources	__string__ is not appropriate for deallocating __string__
Rule22.4	1	Resources	Attempt to perform write operation on stream not opened for writing
Rule22.5	1	Resources	A pointer to a FILE object shall not be dereferenced
Rule22.6	1	Resources	Operation on stream that has been closed