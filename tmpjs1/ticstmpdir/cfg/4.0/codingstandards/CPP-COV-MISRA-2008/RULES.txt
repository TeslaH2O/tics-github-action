COV_MISRA_CPP_2008_Rule_0_1_1	2	Language Independent Issues	A project shall not contain unreachable code.
COV_MISRA_CPP_2008_Rule_0_1_10	4	Language Independent Issues	Every defined function shall be called at least once.
COV_MISRA_CPP_2008_Rule_0_1_11	5	Language Independent Issues	There shall be no unused parameters (named or unnamed) in non-virtual functions.
COV_MISRA_CPP_2008_Rule_0_1_12	5	Language Independent Issues	There shall be no unused parameters (named or unnamed) in the set of parameters for a virtual function and all the functions that override it.
COV_MISRA_CPP_2008_Rule_0_1_2	3	Language Independent Issues	A project shall not contain infeasible paths.
COV_MISRA_CPP_2008_Rule_0_1_3	5	Language Independent Issues	A project shall not contain unused variables.
COV_MISRA_CPP_2008_Rule_0_1_4	5	Language Independent Issues	A project shall not contain non-volatile POD variables having only one use.
COV_MISRA_CPP_2008_Rule_0_1_5	5	Language Independent Issues	A project shall not contain unused type declarations.
COV_MISRA_CPP_2008_Rule_0_1_6	5	Language Independent Issues	A project shall not contain instances of non-volatile variables being given values that are never subsequently used.
COV_MISRA_CPP_2008_Rule_0_1_7	3	Language Independent Issues	The value returned by a function having a non-void return type that is not an overloaded operator shall always be used.
COV_MISRA_CPP_2008_Rule_0_1_8	2	Language Independent Issues	All functions with void return type shall have external side effect(s).
COV_MISRA_CPP_2008_Rule_0_1_9	2	Language Independent Issues	There shall be no dead code.
COV_MISRA_CPP_2008_Rule_0_2_1	2	Language Independent Issues	An object shall not be assigned to an overlapping object.
COV_MISRA_CPP_2008_Rule_0_3_2	3	Language Independent Issues	If a function returns error information, then that error information shall be tested.

COV_MISRA_CPP_2008_Rule_10_1_1	4	Derived Classes	Classes should not be derived from virtual bases.
COV_MISRA_CPP_2008_Rule_10_1_2	4	Derived Classes	A base class shall only be declared virtual if it is used in a diamond hierarchy.
COV_MISRA_CPP_2008_Rule_10_1_3	3	Derived Classes	An accessible base class shall not be both virtual and non-virtual in the same hierarchy.
COV_MISRA_CPP_2008_Rule_10_2_1	3	Derived Classes	All accessible entity names within a multiple inheritance hierarchy should be unique.
COV_MISRA_CPP_2008_Rule_10_3_1	3	Derived Classes	There shall be no more than one definition of each virtual function on each path through the inheritance hierarchy.
COV_MISRA_CPP_2008_Rule_10_3_2	4	Derived Classes	Each overriding virtual function shall be declared with the virtual keyword.
COV_MISRA_CPP_2008_Rule_10_3_3	3	Derived Classes	A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual.

COV_MISRA_CPP_2008_Rule_11_0_1	4	Member Access Control	Member data in non-POD class types shall be private.

COV_MISRA_CPP_2008_Rule_12_1_1	3	Special Member Functions	An object's dynamic type shall not be used from the body of its constructor or destructor.
COV_MISRA_CPP_2008_Rule_12_1_2	3	Special Member Functions	All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes.
COV_MISRA_CPP_2008_Rule_12_1_3	3	Special Member Functions	All constructors that are callable with a single argument of fundamental type shall be declared explicit.
COV_MISRA_CPP_2008_Rule_12_8_1	4	Special Member Functions	A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member.
COV_MISRA_CPP_2008_Rule_12_8_2	3	Special Member Functions	The copy assignment operator shall be declared protected or private in an abstract class.

COV_MISRA_CPP_2008_Rule_14_5_1	4	Templates	A non-member generic function shall only be declared in a namespace that is not an associated namespace.
COV_MISRA_CPP_2008_Rule_14_5_2	4	Templates	A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter.
COV_MISRA_CPP_2008_Rule_14_5_3	4	Templates	A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter.
COV_MISRA_CPP_2008_Rule_14_6_1	4	Templates	In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->.
COV_MISRA_CPP_2008_Rule_14_6_2	3	Templates	The function chosen by overload resolution shall resolve to a function declared previously in the translation unit.
COV_MISRA_CPP_2008_Rule_14_7_1	5	Templates	All class templates, function templates, class template member functions and class template static members shall be instantiated at least once.
COV_MISRA_CPP_2008_Rule_14_7_2	3	Templates	For any given template specialization, an explicit instantiation of the template with the template-arguments used in the specialization shall not render the program ill-formed.
COV_MISRA_CPP_2008_Rule_14_7_3	5	Templates	All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template.
COV_MISRA_CPP_2008_Rule_14_8_1	4	Templates	Overloaded function templates shall not be explicitly specialized.
COV_MISRA_CPP_2008_Rule_14_8_2	4	Templates	The viable function set for a function call should either contain no function specializations, or only contain function specializations.

COV_MISRA_CPP_2008_Rule_15_0_2	4	Exception Handling	An exception object should not have pointer type.
COV_MISRA_CPP_2008_Rule_15_0_3	4	Exception Handling	Control shall not be transferred into a try or catch block using a goto or a switch statement.
COV_MISRA_CPP_2008_Rule_15_1_1	4	Exception Handling	The assignment-expression of a throw statement shall not itself cause an exception to be thrown.
COV_MISRA_CPP_2008_Rule_15_1_2	4	Exception Handling	NULL shall not be thrown explicitly.
COV_MISRA_CPP_2008_Rule_15_1_3	4	Exception Handling	An empty throw (throw;) shall only be used in the compound-statement of a catch handler.
COV_MISRA_CPP_2008_Rule_15_3_1	3	Exception Handling	Exceptions shall be raised only after start-up and before termination of the program.
COV_MISRA_CPP_2008_Rule_15_3_2	3	Exception Handling	There should be at least one exception handler to catch all otherwise unhandled exceptions.
COV_MISRA_CPP_2008_Rule_15_3_3	3	Exception Handling	Handlers of a function-try-block implementation of a class constructor or destructor shall not reference non-static members from this class or its bases.
COV_MISRA_CPP_2008_Rule_15_3_4	3	Exception Handling	Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point.
COV_MISRA_CPP_2008_Rule_15_3_5	3	Exception Handling	A class type exception shall always be caught by reference.
COV_MISRA_CPP_2008_Rule_15_3_6	2	Exception Handling	Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class.
COV_MISRA_CPP_2008_Rule_15_3_7	2	Exception Handling	Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all) handler shall occur last.
COV_MISRA_CPP_2008_Rule_15_4_1	3	Exception Handling	If a function is declared with an exception-specification, then all declarations of the same function (in other translation units) shall be declared with the same set of type-ids.
COV_MISRA_CPP_2008_Rule_15_5_1	2	Exception Handling	A class destructor shall not exit with an exception.
COV_MISRA_CPP_2008_Rule_15_5_2	3	Exception Handling	Where a function's declaration includes an exception specification, the function shall only be capable of throwing exceptions of the indicated type(s).
COV_MISRA_CPP_2008_Rule_15_5_3	3	Exception Handling	The terminate() function shall not be called implicitly.

COV_MISRA_CPP_2008_Rule_16_0_1	4	Preprocessor Directives	#include directives in a file shall only be preceded by other preprocessor directives or comments.
COV_MISRA_CPP_2008_Rule_16_0_2	4	Preprocessor Directives	Macros shall only be #define'd or #undef'd in the global namespace.
COV_MISRA_CPP_2008_Rule_16_0_3	4	Preprocessor Directives	#undef shall not be used.
COV_MISRA_CPP_2008_Rule_16_0_4	5	Preprocessor Directives	Function-like macros shall not be defined.
COV_MISRA_CPP_2008_Rule_16_0_5	3	Preprocessor Directives	Arguments to a function-like macro shall not contain tokens that look like preprocessing directives.
COV_MISRA_CPP_2008_Rule_16_0_6	3	Preprocessor Directives	In the definition of a function-like macro, each instance of a parameter shall be enclosed in parentheses, unless it is used as the operand of # or ##.
COV_MISRA_CPP_2008_Rule_16_0_7	3	Preprocessor Directives	Undefined macro identifiers shall not be used in #if or #elif preprocessor directives, except as operands to the defined operator.
COV_MISRA_CPP_2008_Rule_16_0_8	6	Preprocessor Directives	If the # token appears as the first token on a line, then it shall be immediately followed by a preprocessing token.
COV_MISRA_CPP_2008_Rule_16_1_1	2	Preprocessor Directives	The defined preprocessor operator shall only be used in one of the two standard forms.
COV_MISRA_CPP_2008_Rule_16_1_2	3	Preprocessor Directives	All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related.
COV_MISRA_CPP_2008_Rule_16_2_1	4	Preprocessor Directives	The pre-processor shall only be used for file inclusion and include guards.
COV_MISRA_CPP_2008_Rule_16_2_2	4	Preprocessor Directives	C++ macros shall only be used for include guards, type qualifiers, or storage class specifiers.
COV_MISRA_CPP_2008_Rule_16_2_3	4	Preprocessor Directives	Include guards shall be provided.
COV_MISRA_CPP_2008_Rule_16_2_4	3	Preprocessor Directives	The ', ", /* or // characters shall not occur in a header file name.
COV_MISRA_CPP_2008_Rule_16_2_5	3	Preprocessor Directives	The \ character should not occur in a header file name.
COV_MISRA_CPP_2008_Rule_16_2_6	3	Preprocessor Directives	The #include directive shall be followed by either a <filename> or "filename" sequence.
COV_MISRA_CPP_2008_Rule_16_3_1	2	Preprocessor Directives	There shall be at most one occurrence of the # or ## operators in a single macro definition.
COV_MISRA_CPP_2008_Rule_16_3_2	4	Preprocessor Directives	The # and ## operators should not be used.

COV_MISRA_CPP_2008_Rule_17_0_1	3	Library Introduction	Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined.
COV_MISRA_CPP_2008_Rule_17_0_2	3	Library Introduction	The names of standard library macros and objects shall not be reused.
COV_MISRA_CPP_2008_Rule_17_0_3	3	Library Introduction	The names of standard library functions shall not be overridden.
COV_MISRA_CPP_2008_Rule_17_0_5	4	Library Introduction	The setjmp macro and the longjmp function shall not be used.

COV_MISRA_CPP_2008_Rule_18_0_1	6	Language Support Library	The C library shall not be used.
COV_MISRA_CPP_2008_Rule_18_0_2	5	Language Support Library	The library functions atof, atoi and atol from library <cstdlib> shall not be used.
COV_MISRA_CPP_2008_Rule_18_0_3	4	Language Support Library	The library functions abort, exit, getenv and system from library <cstdlib> shall not be used.
COV_MISRA_CPP_2008_Rule_18_0_4	5	Language Support Library	The time handling functions of library <ctime> shall not be used.
COV_MISRA_CPP_2008_Rule_18_0_5	4	Language Support Library	The unbounded functions of library <cstring> shall not be used.
COV_MISRA_CPP_2008_Rule_18_2_1	4	Language Support Library	The macro offsetof shall not be used.
COV_MISRA_CPP_2008_Rule_18_4_1	5	Language Support Library	Dynamic heap memory allocation shall not be used.
COV_MISRA_CPP_2008_Rule_18_7_1	4	Language Support Library	The signal handling facilities of <csignal> shall not be used.

COV_MISRA_CPP_2008_Rule_19_3_1	4	Diagnostic Library	The error indicator errno shall not be used.

COV_MISRA_CPP_2008_Rule_2_10_1	5	Lexical Conventions	Different identifiers shall be typographically unambiguous.
COV_MISRA_CPP_2008_Rule_2_10_2	3	Lexical Conventions	Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope.
COV_MISRA_CPP_2008_Rule_2_10_3	3	Lexical Conventions	A typedef name (including qualification, if any) shall be a unique identifier.
COV_MISRA_CPP_2008_Rule_2_10_4	3	Lexical Conventions	A class, union or enum name (including qualification, if any) shall be a unique identifier.
COV_MISRA_CPP_2008_Rule_2_10_5	3	Lexical Conventions	The identifier name of a non-member object or function with static storage duration should not be reused.
COV_MISRA_CPP_2008_Rule_2_10_6	4	Lexical Conventions	If an identifier refers to a type, it shall not also refer to an object or a function in the same scope.
COV_MISRA_CPP_2008_Rule_2_13_1	6	Lexical Conventions	Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used.
COV_MISRA_CPP_2008_Rule_2_13_2	6	Lexical Conventions	Octal constants (other than zero) and octal escape sequences (other than "\0") shall not be used.
COV_MISRA_CPP_2008_Rule_2_13_3	5	Lexical Conventions	A "U" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type.
COV_MISRA_CPP_2008_Rule_2_13_4	5	Lexical Conventions	Literal suffixes shall be upper case.
COV_MISRA_CPP_2008_Rule_2_13_5	2	Lexical Conventions	Narrow and wide string literals shall not be concatenated.
COV_MISRA_CPP_2008_Rule_2_3_1	5	Lexical Conventions	Trigraphs shall not be used.
COV_MISRA_CPP_2008_Rule_2_5_1	5	Lexical Conventions	Digraphs should not be used.
COV_MISRA_CPP_2008_Rule_2_7_1	4	Lexical Conventions	The character sequence /* shall not be used within a C-style comment.
COV_MISRA_CPP_2008_Rule_2_7_2	4	Lexical Conventions	Sections of code should not be "commented out" using C-style comments.
COV_MISRA_CPP_2008_Rule_2_7_3	4	Lexical Conventions	Sections of code should not be "commented out" using C++ comments.

COV_MISRA_CPP_2008_Rule_27_0_1	5	Input/Output Library	The stream input/output library <cstdio> shall not be used.

COV_MISRA_CPP_2008_Rule_3_1_1	3	Basic Concepts	It shall be possible to include any header file in multiple translation units without violating the One Definition Rule.
COV_MISRA_CPP_2008_Rule_3_1_2	3	Basic Concepts	Functions shall not be declared at block scope.
COV_MISRA_CPP_2008_Rule_3_1_3	2	Basic Concepts	When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization.
COV_MISRA_CPP_2008_Rule_3_2_1	2	Basic Concepts	All declarations of an object or function shall have compatible types.
COV_MISRA_CPP_2008_Rule_3_2_2	2	Basic Concepts	The One Definition Rule shall not be violated.
COV_MISRA_CPP_2008_Rule_3_2_3	3	Basic Concepts	A type, object or function that is used in multiple translation units shall be declared in one and only one file.
COV_MISRA_CPP_2008_Rule_3_2_4	3	Basic Concepts	An identifier with external linkage shall have exactly one external definition.
COV_MISRA_CPP_2008_Rule_3_3_1	3	Basic Concepts	Objects or functions with external linkage shall be declared in a header file.
COV_MISRA_CPP_2008_Rule_3_3_2	3	Basic Concepts	If a function has internal linkage then all re-declarations shall include the static storage class specifier.
COV_MISRA_CPP_2008_Rule_3_4_1	5	Basic Concepts	An identifier declared to be an object or type shall be defined in a block that minimizes its visibility.
COV_MISRA_CPP_2008_Rule_3_9_1	3	Basic Concepts	The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations.
COV_MISRA_CPP_2008_Rule_3_9_2	5	Basic Concepts	typedefs that indicate size and signedness should be used in place of the basic numerical types.
COV_MISRA_CPP_2008_Rule_3_9_3	3	Basic Concepts	The underlying bit representations of floating-point values shall not be used.

COV_MISRA_CPP_2008_Rule_4_10_1	5	Standard Conversions	NULL shall not be used as an integer value.
COV_MISRA_CPP_2008_Rule_4_10_2	5	Standard Conversions	Literal zero (0) shall not be used as the null-pointer-constant.
COV_MISRA_CPP_2008_Rule_4_5_1	5	Standard Conversions	Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator =, the logical operators &&, ||, and !, the equality operators == and !=, the unary & operator, and the conditional operator.
COV_MISRA_CPP_2008_Rule_4_5_2	4	Standard Conversions	Expressions with type enum shall not be used as operands to built-in operators other than the subscript operator [ ], the assignment operator =, the equality operators == and !=, the unary & operator, and the relational operators <, <=, >, and >=.
COV_MISRA_CPP_2008_Rule_4_5_3	4	Standard Conversions	Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than the assignment operator =, the equality operators == and !=, and the unary & operator.

COV_MISRA_CPP_2008_Rule_5_0_1	2	Expressions	The value of an expression shall be the same under any order of evaluation that the standard permits.
COV_MISRA_CPP_2008_Rule_5_0_10	3	Expressions	If the bitwise operators ~ and << are applied to an operand with an underlying type of unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand.
COV_MISRA_CPP_2008_Rule_5_0_11	4	Expressions	The plain char type shall only be used for the storage and use of character values.
COV_MISRA_CPP_2008_Rule_5_0_12	4	Expressions	signed char and unsigned char type shall only be used for the storage and use of numeric values.
COV_MISRA_CPP_2008_Rule_5_0_13	3	Expressions	The condition of an if-statement and the condition of an iteration-statement shall have type bool.
COV_MISRA_CPP_2008_Rule_5_0_14	3	Expressions	The first operand of a conditional-operator shall have type bool.
COV_MISRA_CPP_2008_Rule_5_0_15	3	Expressions	Array indexing shall be the only form of pointer arithmetic.
COV_MISRA_CPP_2008_Rule_5_0_16	2	Expressions	A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array.
COV_MISRA_CPP_2008_Rule_5_0_17	2	Expressions	Subtraction between pointers shall only be applied to pointers that address elements of the same array.
COV_MISRA_CPP_2008_Rule_5_0_18	2	Expressions	The relational operators >, >=, < and <= shall not be applied to objects of pointer type, except where they point to the same array.
COV_MISRA_CPP_2008_Rule_5_0_19	4	Expressions	The declaration of objects shall contain no more than two levels of pointer indirection.
COV_MISRA_CPP_2008_Rule_5_0_2	5	Expressions	Limited dependence should be placed on C++ operator precedence rules in expressions.
COV_MISRA_CPP_2008_Rule_5_0_20	4	Expressions	Non-constant operands to a binary bitwise operator shall have the same underlying type.
COV_MISRA_CPP_2008_Rule_5_0_21	3	Expressions	Bitwise operators shall only be applied to operands of unsigned underlying type.
COV_MISRA_CPP_2008_Rule_5_0_3	4	Expressions	A cvalue expression shall not be implicitly converted to a different underlying type.
COV_MISRA_CPP_2008_Rule_5_0_4	3	Expressions	An implicit integral conversion shall not change the signedness of the underlying type.
COV_MISRA_CPP_2008_Rule_5_0_5	3	Expressions	There shall be no implicit floating-integral conversions.
COV_MISRA_CPP_2008_Rule_5_0_6	2	Expressions	An implicit integral or floating-point conversion shall not reduce the size of the underlying type.
COV_MISRA_CPP_2008_Rule_5_0_7	3	Expressions	There shall be no explicit floating-integral conversions of a cvalue expression.
COV_MISRA_CPP_2008_Rule_5_0_8	2	Expressions	An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression.
COV_MISRA_CPP_2008_Rule_5_0_9	2	Expressions	An explicit integral conversion shall not change the signedness of the underlying type of a cvalue expression.
COV_MISRA_CPP_2008_Rule_5_14_1	4	Expressions	The right hand operand of a logical && or || operator shall not contain side effects.
COV_MISRA_CPP_2008_Rule_5_18_1	4	Expressions	The comma operator shall not be used.
COV_MISRA_CPP_2008_Rule_5_19_1	2	Expressions	Evaluation of constant unsigned integer expressions should not lead to wrap-around.
COV_MISRA_CPP_2008_Rule_5_2_1	5	Expressions	Each operand of a logical && or || shall be a postfix-expression.
COV_MISRA_CPP_2008_Rule_5_2_10	3	Expressions	The increment (++) and decrement (--) operators should not be mixed with other operators in an expression.
COV_MISRA_CPP_2008_Rule_5_2_11	4	Expressions	The comma operator, && operator and the || operator shall not be overloaded.
COV_MISRA_CPP_2008_Rule_5_2_12	4	Expressions	An identifier with array type passed as a function argument shall not decay to a pointer.
COV_MISRA_CPP_2008_Rule_5_2_2	4	Expressions	A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast.
COV_MISRA_CPP_2008_Rule_5_2_3	4	Expressions	Casts from a base class to a derived class should not be performed on polymorphic types.
COV_MISRA_CPP_2008_Rule_5_2_4	4	Expressions	C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used.
COV_MISRA_CPP_2008_Rule_5_2_5	3	Expressions	A cast shall not remove any const or volatile qualification from the type of a pointer or reference.
COV_MISRA_CPP_2008_Rule_5_2_6	3	Expressions	A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type.
COV_MISRA_CPP_2008_Rule_5_2_7	3	Expressions	An object with pointer type shall not be converted to an unrelated pointer type, either directly or indirectly.
COV_MISRA_CPP_2008_Rule_5_2_8	3	Expressions	An object with integer type or pointer to void type shall not be converted to an object with pointer type.
COV_MISRA_CPP_2008_Rule_5_2_9	2	Expressions	A cast should not convert a pointer type to an integral type.
COV_MISRA_CPP_2008_Rule_5_3_1	4	Expressions	Each operand of the ! operator, the logical && or the logical || operators shall have type bool.
COV_MISRA_CPP_2008_Rule_5_3_2	2	Expressions	The unary minus operator shall not be applied to an expression whose underlying type is unsigned.
COV_MISRA_CPP_2008_Rule_5_3_3	4	Expressions	The unary & operator shall not be overloaded.
COV_MISRA_CPP_2008_Rule_5_3_4	1	Expressions	Evaluation of the operand to the sizeof operator shall not contain side effects.
COV_MISRA_CPP_2008_Rule_5_8_1	2	Expressions	The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand.

COV_MISRA_CPP_2008_Rule_6_2_1	3	Statements	Assignment operators shall not be used in sub-expressions.
COV_MISRA_CPP_2008_Rule_6_2_2	3	Statements	Floating-point expressions shall not be directly or indirectly tested for equality or inequality.
COV_MISRA_CPP_2008_Rule_6_2_3	4	Statements	Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that the first character following the null statement is a white-space character.
COV_MISRA_CPP_2008_Rule_6_3_1	5	Statements	The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement.
COV_MISRA_CPP_2008_Rule_6_4_1	5	Statements	An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement.
COV_MISRA_CPP_2008_Rule_6_4_2	6	Statements	All if ... else if constructs shall be terminated with an else clause.
COV_MISRA_CPP_2008_Rule_6_4_3	2	Statements	A switch statement shall be a well-formed switch statement.
COV_MISRA_CPP_2008_Rule_6_4_4	2	Statements	A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.
COV_MISRA_CPP_2008_Rule_6_4_5	2	Statements	An unconditional throw or break statement shall terminate every non-empty switch-clause.
COV_MISRA_CPP_2008_Rule_6_4_6	3	Statements	The final clause of a switch statement shall be the default-clause.
COV_MISRA_CPP_2008_Rule_6_4_7	2	Statements	The condition of a switch statement shall not have bool type.
COV_MISRA_CPP_2008_Rule_6_4_8	1	Statements	Every switch statement shall have at least one case-clause.
COV_MISRA_CPP_2008_Rule_6_5_1	2	Statements	A for loop shall contain a single loop-counter which shall not have floating type.
COV_MISRA_CPP_2008_Rule_6_5_2	4	Statements	If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to <=, <, > or >=.
COV_MISRA_CPP_2008_Rule_6_5_3	4	Statements	The loop-counter shall not be modified within condition or statement.
COV_MISRA_CPP_2008_Rule_6_5_4	4	Statements	The loop-counter shall be modified by one of: --, ++, -=n, or +=n; where n remains constant for the duration of the loop.
COV_MISRA_CPP_2008_Rule_6_5_5	4	Statements	A loop-control-variable other than loop-counter shall not be modified within condition or expression.
COV_MISRA_CPP_2008_Rule_6_5_6	4	Statements	A loop-control-variable other than the loop-counter which is modified in statement shall have type bool.
COV_MISRA_CPP_2008_Rule_6_6_1	4	Statements	Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement.
COV_MISRA_CPP_2008_Rule_6_6_2	4	Statements	The goto statement shall jump to a label declared later in the same function.
COV_MISRA_CPP_2008_Rule_6_6_3	3	Statements	The continue statement shall only be used within a well-formed for loop.
COV_MISRA_CPP_2008_Rule_6_6_4	3	Statements	For any iteration statement there shall be no more than one break or goto statement used for loop termination.
COV_MISRA_CPP_2008_Rule_6_6_5	5	Statements	A function shall have a single point of exit at the end of the function.

COV_MISRA_CPP_2008_Rule_7_1_1	5	Declarations	A variable that is not modified shall be const qualified.
COV_MISRA_CPP_2008_Rule_7_1_2	5	Declarations	A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the corresponding object is not modified.
COV_MISRA_CPP_2008_Rule_7_2_1	3	Declarations	An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration.
COV_MISRA_CPP_2008_Rule_7_3_1	4	Declarations	The global namespace shall only contain main, namespace declarations and extern "C" declarations.
COV_MISRA_CPP_2008_Rule_7_3_2	3	Declarations	The identifier main shall not be used for a function other than the global function main.
COV_MISRA_CPP_2008_Rule_7_3_3	4	Declarations	There shall be no unnamed namespaces in header files.
COV_MISRA_CPP_2008_Rule_7_3_4	4	Declarations	using-directives shall not be used.
COV_MISRA_CPP_2008_Rule_7_3_5	4	Declarations	Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that identifier.
COV_MISRA_CPP_2008_Rule_7_3_6	4	Declarations	using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files.
COV_MISRA_CPP_2008_Rule_7_4_2	4	Declarations	Assembler instructions shall only be introduced using the asm declaration.
COV_MISRA_CPP_2008_Rule_7_4_3	4	Declarations	Assembly language shall be encapsulated and isolated.
COV_MISRA_CPP_2008_Rule_7_5_1	1	Declarations	A function shall not return a reference or a pointer to an automatic variable (including parameters), defined within the function.
COV_MISRA_CPP_2008_Rule_7_5_2	1	Declarations	The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist.
COV_MISRA_CPP_2008_Rule_7_5_3	1	Declarations	A function shall not return a reference or a pointer to a parameter that is passed by reference or const reference.
COV_MISRA_CPP_2008_Rule_7_5_4	4	Declarations	Functions should not call themselves, either directly or indirectly.

COV_MISRA_CPP_2008_Rule_8_0_1	4	Declarators	An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator respectively.
COV_MISRA_CPP_2008_Rule_8_3_1	3	Declarators	Parameters in an overriding virtual function shall either use the same default arguments as the function they override, or else shall not specify any default arguments.
COV_MISRA_CPP_2008_Rule_8_4_1	4	Declarators	Functions shall not be defined using the ellipsis notation.
COV_MISRA_CPP_2008_Rule_8_4_2	6	Declarators	The identifiers used for the parameters in a redeclaration of a function shall be identical to those in the declaration.
COV_MISRA_CPP_2008_Rule_8_4_3	2	Declarators	All exit paths from a function with non-void return type shall have an explicit return statement with an expression.
COV_MISRA_CPP_2008_Rule_8_4_4	3	Declarators	A function identifier shall either be used to call the function or it shall be preceded by &.
COV_MISRA_CPP_2008_Rule_8_5_1	1	Declarators	All variables shall have a defined value before they are used.
COV_MISRA_CPP_2008_Rule_8_5_2	2	Declarators	Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures.
COV_MISRA_CPP_2008_Rule_8_5_3	3	Declarators	In an enumerator list, the = construct shall not be used to explicitly initialize members other than the first, unless all items are explicitly initialized.

COV_MISRA_CPP_2008_Rule_9_3_1	2	Classes	const member functions shall not return non-const pointers or references to class-data.
COV_MISRA_CPP_2008_Rule_9_3_2	4	Classes	Member functions shall not return non-const handles to class-data.
COV_MISRA_CPP_2008_Rule_9_3_3	5	Classes	If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const.
COV_MISRA_CPP_2008_Rule_9_5_1	4	Classes	Unions shall not be used.
COV_MISRA_CPP_2008_Rule_9_6_2	4	Classes	Bit-fields shall be either bool type or an explicitly unsigned or signed integral type.
COV_MISRA_CPP_2008_Rule_9_6_3	4	Classes	Bit-fields shall not have enum type.
COV_MISRA_CPP_2008_Rule_9_6_4	4	Classes	Named bit-fields with signed integer type shall have a length of more than one bit.